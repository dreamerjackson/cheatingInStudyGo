# 程序控制结构

在之前我们看到的程序都是一行一行顺序执行的，表达能力非常有限，因为我们无法对变量进行测试并根据测试结果执行不同的操作。
例如要模拟如下的数学公式，我们不能通过测试一个数是正数、负数还是零计算一个数的绝对值，并根据规则在不同的情况下执行不同的代码。
<img width="507" alt="image" src="https://user-images.githubusercontent.com/42735226/162561452-6b1d9f8c-e37b-43f2-865a-9c02c3449e17.png">

理论和实践表明，无论多复杂的算法均可通过顺序、选择、循环3种基本控制结构构造出来。
<img width="477" alt="image" src="https://user-images.githubusercontent.com/42735226/162561443-69f3d8a4-3eeb-427f-8863-c853b99e191e.png">

## 顺序结构
按语句出现的先后顺序执行的程序结构，是结构化程序中最简单的结构。编程语言并不提供专门的控制流语句来表达顺序控制结构，而是用程序语句的自然排列顺序来表达。
计算机按此顺序逐条执行语句，当一条语 句执行完毕，控制自动转到下一条语句。现实世界中这种顺序处理的情况是非常普遍的，例如我们接受学校教育一般都是先上小 学，再上中学，再上大学；
又如我们烧菜一般都是先热油锅，再将蔬菜入锅翻炒，再加盐加佐料，最后装盘。

## 选择结构
![image](https://user-images.githubusercontent.com/42735226/162561480-ef40b408-ec6d-4735-98ad-e1bace951865.png)

选择结构又称为分支结构。当程序执行到控制分支的语句时，首先判断条件，根据条件表达式的值选择相应的语句执行(放弃另一部分语句的执行)。分支结构包括单分支、双分支和多分支三种形式。
所有编程语言都提供了条件语句(if 语句)，用来实现有条件地执行语句的功能。
go语言中有if与switch两种结构。if是大多数编程语言中都有的语句，其含义可以理解为"如果"。如下例中，使用if来实现一个简单的猜大小游戏。rand.Intn(10)是一个函数，参数10表示产生10以下的随机数。
通过判断生成的随机数n的大小，打印出不同的字符串。

```
n := rand.Intn(10)
if n == 0 {
    fmt.Println("That's too low")
} else if n > 5 {
    fmt.Println("That's too big:", n)
} else {
    fmt.Println("That's a good number:", n)
}
```

if 语句的语义很容易理解：首先计算 if 后面的条件表达式，如果结果为 True，则控制转 到条件语句体的第一条语句，一旦条件语句体执行完毕，控制即转到 if 语句的下一条语句； 如果结果为 False，则跳过条件语句体，控制直接转到 if 语句的下一条语句。图 1中的流程 图形象地解释了 if 语句的语义，其中菱形框表示条件测试。虽然 if 语句根据条件表达式计算 结果的不同而有两个分支，但我们习惯说这种形式的 if 语句实现的是单分支控制结构，因为 有一个分支什么也不做。注意，无论条件是真是假，最后控制都转到 if 语句的下一条语句， 也就是说这条 if 语句内部虽有两个分支，但总体只有一个出口。

### 程序控制结构两路分支结构
![image](https://user-images.githubusercontent.com/42735226/162561499-c285b07a-6bd2-4f2e-aa32-cda2a2b3fafb.png)

有时我们希望根据条件表达式的不同计算结果(True 或 False)，分别执行两个不同的语句序列，这时可以使用具有两个分支的条件语句形式，即 if-else 语句：
```
if {

 } else{

}
```
if-else 语句的语义是：首先计算条件表达式的值，如果结果为 True，则执行 if-语句体；
如果结果为 False，则执行 else-语句体。无论哪种情况，语句体执行完毕之后，控制都转到 if-else 语句的下一条语句。在使用两路分支的 if 语句时要注意：if 部分和 else 部分必须与一对非此即彼的条件相对 应，一个条件为真则另一个条件必为假，反之亦然。

### 程序控制结构多路分支结构
![image](https://user-images.githubusercontent.com/42735226/162561516-5c77e8b3-dd10-4072-b936-a72dbf585b66.png)
编程语言都都有实现多路分支结构的控制结构。例如，Go 中有语句支持多路分支的条件判断，即 if-else if-else 语句。这条语句在 形式上其实是将嵌套 if-else 语句中的 else 与后续的 if 合并成了一个 else if 子句，形如：
```
if{

}else if{

}else {

}
```
if-else if-else 语句的语义是：顺序计算每一个条件表达式，找到第一个为 True 的条件，然后执行其下方对应的语句体，执行完毕再将控制转到整个 if-else if-else 语句的下一条语句；
如果所有条件表达式的计算结果都是 False，则执行在 else 下方的语句体。
可见，这种形式 的条件语句实现了 n+1 个分支。另外，else 子句是可选的，但要注意的是，如果省略 else 子句，则整个语句就可能没有符合条件的分支，从而不执行任何语句体。

### switch语句
switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上至下逐一测试，直到匹配为止。
switch 语句执行的过程从上至下，直到找到匹配项，匹配项后面也不需要再加 break。
Go语言中 switch 语句的语法如下：
```
switch var1 {
    case val1:
        ...
    case val2,val3:
        ...
    default:
        ...
}
```

与 if 语句的情况一样，不用在 switch 后比较表达式周围加上括号。所有 case 子句（和可选的 default 子句）都包含在一组大括号内。不要在 case 子句的内容周围加上大括号，但是它和花括号的作用一样是一个作用域，因此可以在 case（或default）子句中包含多行，它们都被视为同一作用域的一部分
如下例中，根据指定的某年某月得出有多少天。单个case语句可以有多个判断条件，如下例中，判断月份如果为1、3、5、7、8、10、12中的任意一个月，即可将变量days赋值为31。如果没有匹配的则会走到default分支。
switch 语句可以用if语句完全替代，但是在下例的场景下，switch语句更加清晰易读。
```
//	定义局部变量：年、月、日
	year := 2008
	month := 12
	days := 0

	switch month {
	case 1, 3, 5, 7, 8, 10, 12:
		days = 31
	case 4, 6, 9, 11:
		days = 30
	case 2:
		//判断闰年
		if (year%4 == 0 && year%100 != 0) || year%400 == 0 {
			days = 29
		} else {
			days = 28
		}
	default:
		days = -1
	}
	fmt.Printf("%d年%d月的天数为：%d", year , month , days)
```

switch语句还具有第二种形式,switch后不跟任何变量，case子语句后为bool表达式。
```
switch  {
    case exp1:
        ...
    case exp2:
        ...
    default:
        ...
}
```

如下例所示，判断score变量的大小，并打印出不同的等级。
```
func main(){
	score :=56
	switch{
	case score >=90:
		fmt.Printf("优秀")
	case score >=80:
		fmt.Printf("良好")
	case score >=70:
		fmt.Printf("中等")
	case score >=60:
		fmt.Printf("及格")
	default:
		fmt.Printf("不及格")
	}
}
```


## 循环结构
<img width="655" alt="image" src="https://user-images.githubusercontent.com/42735226/162562072-920150a0-a339-4108-9f85-8fa72a824556.png">
采用循环结构可以实现有规律的重复计算处理。循环结构拥有三个要素：循环变量、循环体和循环终止条件。
当程序执行到循环控制语句时，根据循环判定条件对一组语句重复执行多次。循环结构可以看成是一个条件判断语句和一个转向语句的组合。
与 C 系列中的其他语言一样，Go 使用 for 语句进行循环。 Go 与其他语言的不同之处在于 for 是该语言中唯一的循环关键字。 Go 通过使用四种不同格式的 for 语句来实现这一点：
* 完整的 C 风格的for循环
* 只有条件判断的for循环
* 无限循环的for循环
* for-range 循环

## 完整的 C 风格的for循环
如上例中，就像 if 语句一样，for 语句的部分周围没有括号，完整的 C 风格的for循环共有三部分，用分号隔开。第一个是在循环开始之前设置一个或多个变量的初始化，必须使用 := 来初始化变量； var 在这里是不合法的
第二部分必须是一个计算结果为布尔值的表达式。在循环体运行之前和循环体结束之后立即对其进行检查。如果表达式的计算结果为真，则继续执行循环体。
for 语句标准的最后一部分通常会在这里看到类似 i++的自增语句，但任何赋值语句都是有效的。它在每次循环体结束之后，在判断表达式2是否为true之前运行。
例如下例中打印出1-10的数字
```
for i := 0; i < 10; i++ {
    fmt.Println(i)
}
```

## 只有条件判断的for循环
Go语言的for循环允许只有条件判断语句。这种功能类似于 C、Java、JavaScript、Python、Ruby 和许多其他语言中的 while 语句。
如下例中，打印出1-200内的偶数。只要` i < 100` 就一直执行for循环体内部的语句
```
i := 1
for i < 100 {
        fmt.Println(i)
        i = i * 2
}
```

## 无限循环的for循环
Go 语言中第三种 for 语句格式连条件判断也没有了，是一个永远循环的 for 循环语句。如下例中，无限循环的打印出"hello"
```
func main() {
    for {
        fmt.Println("Hello")
    }
}
```

## for-range 语句
第四种 for 语句格式用于迭代某些 Go 内置类型中的元素。它被称为 for-range 循环，类似于其他语言中的迭代器。在后面介绍复杂的Go内置结构时，会经常看到它的身影。
如下例中，循环遍历一个切片中的元素。
```
evenVals := []int{2, 4, 6, 8, 10, 12}
for i, v := range evenVals {
    fmt.Println(i, v)
}
```
结果为：
```
0 2
1 4
2 6
3 8
4 10
5 12
```
for-range 循环的有趣之处在于您获得了两个循环变量。第一个变量i是数据在被迭代的数据结构中的位置，而第二个变量v代表值。
两个循环变量的惯用名称取决于循环的内容。在遍历数组、切片或字符串时，通常使用 i 表示索引。在遍历map时，将使用 k 代表键
第二个变量通常称为 v 来表示值，但有时会根据被迭代的值的类型来命名。当然，你可以给变量起任何你喜欢的名字。如果循环体中只有几条语句，单字母变量名可以很好地工作。对于更长的（或嵌套的）循环，您需要使用更具描述性的名称。

如果您不需要在 for-range 循环中使用某一个变量，请使用下划线 (_) 作为变量名。这告诉 Go 语言 忽略该值。如下所示，在for-range 循环中忽略索引。
```
evenVals := []int{2, 4, 6, 8, 10, 12}
for _, v := range evenVals {
    fmt.Println(v)
}
```

程序运行结果为：
```
2
4
6
8
10
12
```

## break &&  continue
一个无限循环的for语句要如何中止呢？可以使用`break`语句。就像其他语言中的 break 语句一样，其立即退出循环。当然，您可以将 break 与任何 for 语句一起使用，而不仅仅是无限的 for 语句。
其形式如下所示:
```
for {
    // 省略其他执行语句
    if bool表达式{
        break
    }
}
```
Go 还包括 continue 关键字，它跳过 for 循环的其余部分并直接进行下一次迭代。使用continue语句不是必要的，但其可以更容易地帮助你理解正在发生的事情。

例如下面的代码，由于相互嵌套不容易理解。
```
for i := 1; i <= 100; i++ {
    if i%3 == 0 {
        if i%5 == 0 {
            fmt.Println("FizzBuzz")
        } else {
            fmt.Println("Fizz")
        }
    } else if i%5 == 0 {
        fmt.Println("Buzz")
    } else {
        fmt.Println(i)
    }
}

```

上述代码可以改写为：
```
for i := 1; i <= 100; i++ {
    if i%3 == 0 && i%5 == 0 {
        fmt.Println("FizzBuzz")
        continue
    }
    if i%3 == 0 {
        fmt.Println("Fizz")
        continue
    }
    if i%5 == 0 {
        fmt.Println("Buzz")
        continue
    }
    fmt.Println(i)
}
```

## Labels
默认情况下，break 和 continue 关键字适用于直接包含它们的 for 循环。如果您嵌套了 for 循环并且想要退出或跳过最外部的循环怎么办？这正是标签的作用。如下例所示，循环遍历切片中的每一个字符串。当发现字符串中带有l时，退出内层循环，继续最外层的循环。
```
func main() {
    samples := []string{"hello", "apple_π!"}
outer:
    for _, sample := range samples {
        for i, r := range sample {
            fmt.Println(i, r, string(r))
            if r == 'l' {
                continue outer
            }
        }
        fmt.Println()
    }
}
```

标签总是缩进到与作用域的花括号相同的级别。这使其更容易被注意到。和上例类似，带有标签的嵌套 for 循环很少见。它们最常用于实现类似于以下伪代码的算法：
```
outer:
    for _, outerVal := range outerValues {
        for _, innerVal := range outerVal {
            // 处理 innerVal
            if invalidSituation(innerVal) {
                continue outer
            }
        }
        // 所有innerVal被成功处理后，才会执行下面的代码
    }
```