# 第十章:复合类型

&#x20;      在之前我们都是对于简单的数据进行操作。对于我们希望使用计算解决的许多问题，简单的数据是不够的。程序通常设计用于对复杂现象进行建模，并且改建模的对象通常具有多种不同的特性。&#x20;

&#x20;      因此高级程序语言为我们构造了用简单类型以某种方式组合起来的复合类型。复合类型将我们对程序设计的抽象提升到一个更高的级别，增加设计的模块化，并增强语言的表达能力。 例如，考虑我们要处理分数。分数有分子和分母之分，如果我们只有基础的数据类型，这种处理将变得繁琐。而如果有了复合类型。我们可以将分子和分母看做一个整体。&#x20;

&#x20;      形成复合数据的关键是编程语言应该提供某种“胶水”，以便可以组合数据对象以形成更复杂的数据对象。这种数据抽象将使程序更易于设计、维护和修改。 在本章中我们将看到Go语言中内置的复合类型数组、切片、哈希表，以及用户自定义的结构体如何提供了上述描述的优势。

## 数组

&#x20;      几乎所有主流语言都支持数组，它是相同类型的元素组合而成的列表，是一片连续的内存区域。在现实很多场景中，都需要将一组对象作为一个整体捆绑在一起，便于操作和查找，他们常常还是有序的。例如一个班级中的学生，一本书籍的目录。 数组的声明有多种形式，如下简单的声明指定数组的元素类型和长度。

```
var arr [3]int
```

可以在声明的同时为数组赋值，如

```
var arr2= [4]int{1,2,3,4}
```

如果想定义一个稀疏数组（大多数元素设置为零值的数组），可以仅对数组中有值的元素进行赋值。如下所示：

```
var x = [12]int{1, 5: 4, 6, 10: 100, 15}
```

上面定义的数组x是拥有12个int元素，其值为： \[1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15]. 数组还有一种语法糖，可以不用指定类型

```
arr3 :=[...]int{2,3,4}
```

&#x20;      这种声明方式在编译时自动推断长度。Go 中的数组很少使用，与其他语言中的数组有显著不同的特性。这是因为其有诸多限制：例如不能进行扩容，Go 将数组的大小视为数组类型的一部分。 这使得声明为\[3]的数组与声明为\[4]int的数组不同。数组的大小无法改变，因为数组类型在编译时即解析，而不是在运行时解析。同时无法将不同大小的数组相互转换，所以无法编写适用于任何大小数组的函数，也无法将不同大小的数组分配给同一个变量。&#x20;

&#x20;      要读取数组中的元素，可以指定数组的索引。索引以从零开始的位置进行，这意味着第一个元素的索引是 array\[0]，最后一个元素的索引是 array\[len(array)-1] . 注意索引不能够为负数或者超过数组的大小。否则会在编译时或者运行时出现严重错误。

```
x[0] = 10
fmt.Println(x[2])
```

&#x20;      您不能读取或写入超出数组末尾的索引或使用负索引，否则会出现编译错误。带有变量索引的越界读取或写入编译但在运行时会因恐慌而失败（我们将在“恐慌和恢复”中详细讨论恐慌）。 最后，go提供了内置的函数len用于获取数组的长度。

```
fmt.Println(len(x))
```

&#x20;      更复杂的，我们还可以构造出二维数组，例如var x \[2]\[3]int,形式上可以将其想象为数组中每一个元素又都是数组。这种二维数组在可以模拟类似棋盘游戏等需要二维的场景。例如可以将 a\[1]\[2] 代表棋盘上第一行第2列的元素。 如下例所示，使用二维数组模拟打印出一个五子棋棋盘，并且可以存储当前红黑双方落子的情况。X代表红方，O代表黑方。我们会看到，再复杂的图形化界面背后都离不开这些简单的数据结构和逻辑。随着学习的深入，我们可以实现人人对战，人机对战的五子棋程序了。你可能会感到不可思议，其实现在你就有能力书写这样的程序了！

```
func main() {
	var arr = [5][5]int{}
	arr[2][2] = 1
	arr[2][3] = 2
	for i := 0; i < len(arr); i++ {
		for j := 0; j < len(arr[i]); j++ {
			switch arr[i][j] {
			case 0:
				fmt.Printf("%3s", ".")
			case 1:
				fmt.Printf("%3s", "X")
			case 2:
				fmt.Printf("%3s", "O")
			}
		}
		fmt.Println()
	}
}
```

## slice切片

&#x20;      由于数组的诸多限制，在Go程序中更多是使用切片，切片提供了扩容等更强的能力，并且可以写一个函数用于处理不同长度的切片。 Go 语言中的切片（slice）在某种程度上和其他语言（例如C语言）中的数组在使用中有许多相似的地方。 但是Go 语言中的切片也有许多独特之处，例如，切片是长度可变的序列。序列中的每个元素都有相同的类型。一个切片一般写作\[]T，其中T 代表slice 中元素的类型。&#x20;

&#x20;      和数组不同的是，切片不用指定固定长度。切片有多种声明方式，如下所示，在初始化情况下可以不用声明数组的长度。对于切片numbers，编译器会自动推断出切片初始化的长度，并使其容量与长度相同。

```
var slice1 []int
numbers:= []int{1,2,3,4,5,6,7,8}
```

和数组一样，切片也可以定义稀疏矩阵。

```
var x = []int{1, 5: 4, 6, 10: 100, 15}
```

这将创建一个具有12 个整数的切片：\[1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15]。

除了上面提到的使用初始化的方式，实际中更常见的的方式是使用内置函数make，如下所示：

```
var slice2 []int = make([]int,5)
var slice3 []int = make([]int,5,7)
```

&#x20;      切片有长度和容量的区别，可以在初始化时指定。由于切片具有可扩展性，所以当它的容量比长度大时，意味着为切片元素的增长预留了内存空间。上例中slice2 指定了长度为5 的int切片，如果不指定容量，则默认其容量与长度相同。 slice3第二个参数7声明切片的容量。内置的len 和cap 函数可以分别获取切片的长度和容量。

```
slice := make([]int,0)
fmt.Printf("len=%d,cap=%d,slice=%v\n",len(slice),cap(slice),slice)
```

### append

切片初始化时的长度可以声明为0。

```
var slice2 []int = make([]int,0)
```

&#x20;      这在不明确切片的大小和运行中切片是否有值时很有用，这不用分配额外的内存。相反，如果我们初始化时就知道切片大概的大小，在初始化时一般会提前声明切片的大小。这主要是为了避免切片扩容过程中多余的操作。 切片拥有增加元素，即扩容的能力。可以使用内置的append函数添加值。

```
var x []int
x = append(x, 10)
```

&#x20;      append 函数至少有两个参数，一个任意类型的切片和一个该类型的值。append函数返回相同类型的切片，同时返回的切片需要分配回传入的切片。 append 也可以添加多个值：

```
x = append(x, 5, 6, 7)
```

使用"..."操作符,还可以将一个切片添加到另一个切片中，

```
y := []int{20, 30, 40}
x = append(x, y...)
```

&#x20;      append这种写法看起来有点奇怪而且重复，为什么需要将append函数返回的值再赋值给传入的值，而不是直接append(x,value)呢？这涉及到go语言的设计哲学，即参数传递是值拷贝。传入到函数中的参数x会建立一个新的副本。因此需要将添加元素后返回的新副本赋值给原始的变量。

### 切片的容量

&#x20;      切片是一个序列，切片中的每个元素都被分配到连续的内存位置，这样可以快速读取或写入这些值。 由于切片可以动态扩容，切片拥有容量这一新概念，即保留的连续元素的数量，容量可以大于长度。每次附加到切片时，都会将一个或多个值添加到切片的末尾。每增加1个值，长度就会增加1。&#x20;

&#x20;      当长度达到容量时，就没有更多的空间来放置值了。如果当前切片的长度等于容量时添加其他值会发生什么呢？这时 append 函数会自动分配具有更大容量的新切片，将原始切片中的值复制到新切片中，将新值添加到末尾，并返回新切片。&#x20;

&#x20;      内置的函数len和cap可以获取切片的大小和容量。扩容时并不是每一次只增加一个元素大小，这样效率太低了，相反，扩容时有一些策略使得一次扩容多个元素大小，但是讨论这些策略超出了本书的范围，可参阅《Go语言底层原理剖析》。 但我们可以通过下面的案例观察切片的长度和容量随着append的变化。

```
var x []int
fmt.Println(x, len(x), cap(x))
x = append(x, 10)
fmt.Println(x, len(x), cap(x))
x = append(x, 20)
fmt.Println(x, len(x), cap(x))
x = append(x, 30)
fmt.Println(x, len(x), cap(x))
x = append(x, 40)
fmt.Println(x, len(x), cap(x))
x = append(x, 50)
fmt.Println(x, len(x), cap(x))
```

### 切片的截取

&#x20;      和数组一样，切片中的数据仍然是内存中的一片连续区域。要获取切片某一区域的连续数据，可以通过下标的方式对切片进行截断。 其形式为在方括号内，由一个起始偏移量和一个结束偏移量组成，并且用冒号分隔。如果省略了起始偏移量，则起始偏移量为0。同样，如果省略了结束偏移量，则代表到达切片的结尾。 被截取后的切片，其长度和容量都发生了变化。

```
numbers:= []int{1,2,3,4,5,6,7,8}
// 从下标2 一直到下标4，但是不包括下标4
numbers1 :=numbers[2:4]
// 从下标0 一直到下标3，但是不包括下标3
numbers2 :=numbers[:3]
// 从下标3 一直到结尾
numbers3 :=numbers[3:]
```

&#x20;      如下，变量number1 包含了切片中第2、3 号元素。切片的长度变为了2，容量变为了6，即从第2号元素开始到切片的末尾。 有时候我们希望number1的容量不是6，而是和长度相同，可以使用如下更复杂的截取形式。如下number4方括号中最后的元素4代表窃取后的新切片的容量是序列4。

```
func main() {
	numbers := []int{1, 2, 3, 4, 5, 6, 7, 8}
	// 从下标2 一直到下标4，但是不包括下标4
	numbers1 := numbers[2:4]
	fmt.Println("len:", len(numbers1), "cap:", cap(numbers1))
	numbers4 := numbers[2:4:4]
	fmt.Println("len:", len(numbers4), "cap:", cap(numbers4))
}
```

输出结果为：

```
len: 2 cap: 6
len: 2 cap: 2
```

&#x20;      为什么我们在有些时候需要控制截取后切片的容量呢？这是由于原始切片中的任何未使用容量也与任何子切片共享。这可能导致严重的问题。 切片被截取时有一个重要的特点，被截取后的切片仍然指向原始切片的底层数据。如下所示，y截取了切片x的前两个元素，其容量为4。

```
x := []int{1, 2, 3, 4}
y := x[:2]
fmt.Println(cap(x), cap(y))
y = append(y, 30)
fmt.Println("x:", x)
fmt.Println("y:", y)
```

由于x与y共享同样的底层数组，因此当切片y `append` 一个元素时，其实际上也修改了切片x的值。上例输出为：

```
4 4
x: [1 2 30 4]
y: [1 2 30]
```

但是如果我们限制了变量y的容量和长度相同，那么y在append时候会进行扩容，扩容后新的切片的底层数据将不会再和切片x共享。如下所示，其最终的结果和上例不同，这种不明确的特性是使用切片过程中一个常见的陷阱。

```
	x := []int{1, 2, 3, 4}
	y := x[:2:2]
	fmt.Println(cap(x), cap(y))
	y = append(y, 30)
	fmt.Println("x:", x)
	fmt.Println("y:", y)
```

输出为：

```
4 2
x: [1 2 3 4]
y: [1 2 30]
```

由于切片截取时候的陷阱，我们在实际使用时需要谨慎使用，特别是遇到切片截取 和append函数复用时，在必要时，限制新切片的容量，从而避免新的切片和旧的切片的区别。

### slice底层结构

&#x20;      简单介绍一下切片的底层结构是怎么样的，这是由于对于slice底层结构的认识，可以让我们更加理解切片在截取时候为什么会产生不同的行为。 切片运行时结构如下所示：

```
foo := make([]int,5)
foo[3] = 42
foo[4] = 100
bar := foo[1:4]
bar[1] = 99
```

&#x20;      在这段代码中，bar 截取了foo 切片中间的元素，并修改了bar 中的第2 号元素，程序执行完成后，其底层结构如图所示， 我们可以看到，切片的截取或者复制其实都是创建了一个新的副本结构，其长度和容量发生了变化，但是指向的底层结构是相同的。而当副本在apend扩容之后，由于其指向了新的底层数据，因此变得互不影响。

## 哈希表
Go语言中的map又被称为哈希表，其类型可写为map[keyType]valueType。和切片处理顺序数据不同的是，哈希表适用于存储key-value这样的键值对。
想象一下这样的场景，如果在切片中存储了1本书的所有章节，那么要查找某一个章节的内容，就需要遍历整个切片，就好像我们从前往后翻阅了整本书。
如果现实中的真实情况却是，每一本书都有一个目录，读者根据目录查找到某一个章节所处的页码，即可直接定位到对应的内容。哈希表正适合这样的场景，根据指定的key能快速定位到value。
哈希表的原理是将多个键/值（key/value）对分散存储在buckets（桶）中。给定一个键（key），哈希（Hash）算法会计算出键值对存储的位置。通常包括两步，伪代码如下：
```
hash = hashfunc(key)
index = hash % array_size
```
在此伪代码中，第一步通过哈希算法计算键的哈希值，其结果与桶的数量无关。接着通过执行取模运算得到0−array_size−1 之间的序号，找到对应的桶，即可查找或设置对应的value。
在这里当存储元素的数量大于了桶的数量，那么必要会发生多个元素对应同一个桶的情况。如果将2450个键随机分配到一百万个桶中，则根据概率计算，至少有两个键被分配到同一个桶中的可能性有惊人的95％。这种特性被称为"哈希冲突"，关于哈希冲突的详细介绍可参阅笔者的《Go语言底层原理剖析》

### map 声明与初始化
先看 map 的基本使用方式。map 的第一种声明方式如下：
```
var hash map[T]T
```
其并未对map 进行初始化操作，值为nil，因此一旦进行hash[key]=value 这样的赋值操作就会报错。
```
panic(plainError("assignment to entry in nil map"))
```
比较意外的是，Go 语言允许对值为nil 的map 进行访问，虽然结果毫无意义。
map 的第二种声明方式是通过make 函数初始化。make 函数中的第二个参数代表初始化创建map 的长度，当NUMBER 为空时，其默认长度为0。
和切片一样，如果我们知道map可能的大小，则需要在初始化时声明map的大小，这是因为map和切片一样，具有在运行时自动扩容的特性。这种特性会减慢运行速度。
```
var hash = make(map[T]T,NUMBER)
```

此种方式可以正常地对map进行访问与赋值。map 还有字面量形式初始化的方式，如下所示，country与rating在创建map时即在其中添加了元素。
```
var country = map[string]string{
"China": "Beijing",
"Japan": "Tokyo",
"India": "New Delhi",
"France": "Paris",
"Italy": "Rome",
}
rating := map[string]float64{"c": 5, "Go": 4.5, "Python": 4.5, "C++": 3}
```

## map 访问
map 可以进行以下两种形式的访问：
```
v := hash[key]
v,ok := map[key]
```
当返回两个参数时，第2个参数代表当前key 在map 中是否存在。如下为map赋值与读取的样例
```
totalWins := map[string]int{}
totalWins["Orcas"] = 1
totalWins["Lions"] = 2
fmt.Println(totalWins["Orcas"])
fmt.Println(totalWins["Kittens"])
totalWins["Kittens"]++
fmt.Println(totalWins["Kittens"])
totalWins["Lions"] = 3
fmt.Println(totalWins["Lions"])
```
读取map返回两个参数形式的例子：
```
m := map[string]int{
    "hello": 5,
    "world": 0,
}
v, ok := m["hello"]
fmt.Println(v, ok)
```

### map 赋值
map 的赋值语法相对简单，例如hashmap[key] = value 代表将value 与哈希表中的key 绑定在一起。
delete 是Go 语言中的关键字，用于删除map中的指定key，形如delete(hashmap,key)，可以对相同的key进行多次删除操作而不会报错。
```
m := map[string]int{
    "hello": 5,
    "world": 10,
}
delete(m, "hello")
```

### 使用map的一个例子：缓存
map的使用场景很多，在这里举一个实际例子。假设我们需要抢火车票，但是同一个人最多只能抢一张。因此我们简单的用map存储某一个人是否已经抢过票。
```
var cache = map[string]int{}
if _.ok := cache["xxx"];!ok{
    // xxx不存在于cache中，执行抢票
    //...
    // 设置cache，标识xxx已经抢过票了
    cache["xxx"] = true
}else{
    // xxx已经抢过票了，直接返回
    return
}
```

## 结构体
在之前介绍了go语言中内置的简单类型和复合数据类型的使用方法，它们是构建复杂逻辑的基础。在本小节中，将介绍通过将简单类型和复合类型组合起来的自定义类型—————结构体。
我们将看到结构体的使用如何真正提高编程语言的表达能力。
例如，我们已经能够计算整数简单的加减乘除逻辑。现在希望实现一个分数的计算逻辑。如果没有自定义结构体的抽象，例如要实现一个分数的加法函数可能如下所示。在这里函数的参数是一长串的分子与分母。
当我们调用add函数时候，还需要保证正确的传递了第一个参数为第一个数字的分子，第二个参数为第二个数字的分母...,这也意味着add函数的调用者不仅仅需要小心的排列其传递的参数，并且需要关注add函数内存执行和返回的细节。这将阻碍我们构建更大规模的程序。
```
func add(n1 int,d1 int,n2 int,d2 int) (int,int){
    return (n1*d2 + n2*d1), (d1*d2)
}
```

### 结构体声明与赋值
我们稍后将会看到，结构体如何帮助构建起更强悍的抽象。在这之前，我们先看看结构体的简单用法。假设我们要构建一个分数的结构体，其形式如下所示：
```
type Nat struct {
    n  int
    d  int
}
```
结构体的定义由关键字`type`, 结构体名字，关键字`struct`，花括号`{}`组成。在花括号内部，列出了结构体的中字段名以及其类型。
一旦声明了结构类型，我们就可以定义该类型的变量：
```
var nat1 Nat
```
在这里由于没有为nat1分配任何值，其内部值均为0。也可以在初始化时即为结构体赋值，第一种形式如下:
```
nat1 := Nat{
    2,
    3
}
```
使用这种结构字面量格式时，必须为结构中的每个字段指定一个值，并且这些值按照它们在结构定义中声明的顺序分配给对应字段。
第二种初始化赋值的方式和map类型：
```
nat1 := person{
    d:  3,
    n:  2,
}
```
这种方式更加清晰，因为指定了要分配的字段名字，因此不必保证有序性，同时可以省略掉一些不必赋值的字段。
要访问或者对结构体变量中的字段进行赋值，可以使用：
```
nat1.n = 4
fmt.Println(nat1.n)
```

### 匿名结构体
结构体有一种特殊的匿名形式，其不用声明结构体的名字。如下所示，person和pet变量都是匿名结构体。
```
var person struct {
    name string
    age  int
    pet  string
}

person.name = "bob"
person.age = 50
person.pet = "dog"

pet := struct {
    name string
    kind string
}{
    name: "Fido",
    kind: "dog",
}
```
在进行测试或者进行json序列化反序列化等场景，可能会看到匿名结构体的身影。匿名结构体只是一种更加简洁的表现形式。
### 结构体的比较
```

```


## 参考资料

*《Structure and Interpretation of Computer Programs》 Chapter2 Building Abstractions with Data
