# Go命令行工具

在书写`Hello World`程序时，我们用`go run main.go` 或者`go build main.go` 这两个命令达到将源文件编译成可执行文件的目的。
go命令是管理源文件的工具,其除了编译文件，还具有其他丰富的功能。如下执行go会看到有多种子命令可供选择。
```
» go
Go is a tool for managing Go source code.

Usage:

	go <command> [arguments]

The commands are:

	bug         start a bug report
	build       compile packages and dependencies
	clean       remove object files and cached files
	doc         show documentation for package or symbol
	env         print Go environment information
	fix         update packages to use new APIs
	fmt         gofmt (reformat) package sources
	generate    generate Go files by processing source
	get         add dependencies to current module and install them
	install     compile and install packages and dependencies
	list        list packages or modules
	mod         module maintenance
	run         compile and run Go program
	test        test packages
	tool        run specified go tool
	version     print Go version
	vet         report likely mistakes in packages

Use "go help <command>" for more information about a command.
```

| command | 说明                                                                  |
|--------|-----------------------------------------------------------------------|
| go bug    | 打开浏览器，报告错误信息                                               |
| go build    | 编译源代码 |
| go clean    | 移除目标文件和缓存文件                                                      |
| go env    | 打印Go环境信息                                                      |
| go fix   | 更改包，使用新的api             |
| go fmt    | 格式化源文件                                          |
| go generate    | 通过处理源生成 Go 文件                                                          |
| go get   | 添加依赖并安装                                                             |
| go list   | 打印包或模块                                                         |
| go mod   | 依赖管理                                                         |
| go run   | 编译并运行源代码                                                       |
| go test   | 测试代码                                                       |
| go tool   | 运行特殊的go工具                                                       |
| go version   | 打印go版本                                                       |
| go vet   | 报告代码中可能的错误                                                       |

要详细查看每个命令的使用方法，可以使用`go help <command>` 打印出帮助文档，例如
```
» go help fmt
usage: go fmt [-n] [-x] [packages]

Fmt runs the command 'gofmt -l -w' on the packages named
by the import paths. It prints the names of the files that are modified.

For more about gofmt, see 'go doc cmd/gofmt'.
For more about specifying packages, see 'go help packages'.

The -n flag prints commands that would be executed.
The -x flag prints commands as they are executed.

The -mod flag's value sets which module download mode
to use: readonly or vendor. See 'go help modules' for more.

To run gofmt with specific options, run gofmt itself.

See also: go fix, go vet.

```

有一些命令的使用方法可能相对复杂，例如go tool拥有查看程序性能等很多丰富的功能，在后面的性能分析中会看到它的用途。go mod 用于处理程序的依赖关系，这是构建大型项目的关键,我们将在后面依赖管理中进行专门介绍。go generate一般用于根据配置模板生成go文件，在实际中使用很少，一般在特殊场景下会用到。 下面以几个常用的命令举例：

### go fmt
用于格式化包，项目中代码可能会存在代码缩进，空格空行多等问题。`go fmt`能够识别有问题的文件，将代码修正为规范化的代码，并打印出修改的文件名。`go fmt` 本质上是调用了gofmt命令。
格式化后的代码有如下好处：
* 容易读：不必将其他人的代码格式转换为可以理解的内容
* 容易写：在书写代码时可不用过于关心格式化问题
* 容易维护：对源代码的改动不会引起不相关的改动，diff只会显示真正的代码改动
格式化代码除了调用`go fmt`命令例如：
```
go fmt path/to/your/package
```
也可以直接使用`gofmt` 命令：
```
gofmt -w yourcode.go
```

`gofmt` 还可以完成替换的作用，这里不再展开，可以查看帮助文档或者文后的参考资料。
```
» gofmt --help
usage: gofmt [flags] [path ...]
  -cpuprofile string
        write cpu profile to this file
  -d    display diffs instead of rewriting files
  -e    report all errors (not just the first 10 on different lines)
  -l    list files whose formatting differs from gofmt's
  -r string
        rewrite rule (e.g., 'a[b:len(a)] -> a[b:]')
  -s    simplify code
  -w    write result to (source) file instead of stdout
```

### go doc
Go 项目非常重视文档。文档是使软件可访问和可维护的重要组成部分。当然，它必须写得好且准确，但也必须易于编写和维护。理想情况下，它应该与代码本身耦合，以便文档与代码一起发展。
因此Go官方开发了 godoc 文档工具 godoc 解析 Go 源代码 - 包括注释 - 并将文档生成为 HTML 或纯文本。最终结果是文档与它记录的代码紧密耦合。
约定很简单：要记录类型、变量、常量、函数甚至包，在其声明之前直接写一个常规注释，中间没有空行。 Godoc 会将该注释作为文本呈现在它所记录的项目旁边。例如，这是 fmt 包的 Fprint 函数的文档：
```
// Fprint formats using the default formats for its operands and writes to w.
// Spaces are added between operands when neither is a string.
// It returns the number of bytes written and any write error encountered.
func Fprint(w io.Writer, a ...interface{}) (n int, err error) {
```
对包声明的注释应提供包使用目的的文档。这些注释可以很短，例如 sort 包的简要说明：
```
// Package sort provides primitives for sorting slices and user-defined
// collections.
package sort
```
注意和fmt一样，有两种方式可以使用文档工具，分别是godoc和go doc。godoc是一个单独的工具，功能更丰富，目前go新版本不会自动安装。`go doc`是go命令的子命令，
默认情况下，godoc 通过 $GOROOT 和 $GOPATH查看它找到的包,例如我们需要查看fmt包的Fprint函数
```
» go doc fmt.Fprint
package fmt // import "fmt"

func Fprint(w io.Writer, a ...interface{}) (n int, err error)
    Fprint formats using the default formats for its operands and writes to w.
    Spaces are added between operands when neither is a string. It returns the
    number of bytes written and any write error encountered.
```
查看fmt包的Fprint函数的源代码可以使用`-src`参数：
```
» go doc -src  fmt.Fprint
package fmt // import "fmt"

// Fprint formats using the default formats for its operands and writes to w.
// Spaces are added between operands when neither is a string.
// It returns the number of bytes written and any write error encountered.
func Fprint(w io.Writer, a ...interface{}) (n int, err error) {
        p := newPrinter()
        p.doPrint(a)
        n, err = w.Write(p.buf)
        p.free()
        return
}
```

### go vet

Vet 是代码静态诊断器。检查 Go 源代码并报告可能有问题的地方，例如错误的锁使用、不必要的赋值。 Vet 使用的启发式方法不能保证所有报告都是真正的问题，但它可以找到编译器未捕获的错误。Vet包含多种类型的检查：
可通过`go tool vet help` 命令查看：
```
asmdecl      report mismatches between assembly files and Go declarations
assign       check for useless assignments
atomic       check for common mistakes using the sync/atomic package
bools        check for common mistakes involving boolean operators
buildtag     check that +build tags are well-formed and correctly located
cgocall      detect some violations of the cgo pointer passing rules
composites   check for unkeyed composite literals
copylocks    check for locks erroneously passed by value
httpresponse check for mistakes using HTTP responses
loopclosure  check references to loop variables from within nested functions
lostcancel   check cancel func returned by context.WithCancel is called
nilfunc      check for useless comparisons between functions and nil
printf       check consistency of Printf format strings and arguments
shift        check for shifts that equal or exceed the width of the integer
stdmethods   check signature of methods of well-known interfaces
structtag    check that struct field tags conform to reflect.StructTag.Get
tests        check for common mistaken usages of tests and examples
unmarshal    report passing non-pointer or non-interface values to unmarshal
unreachable  check for unreachable code
unsafeptr    check for invalid conversions of uintptr to unsafe.Pointer
unusedresult check for unused results of calls to some functions
```
默认情况下，会执行所有检查。如果任何标志显式设置为 true，则仅运行那些测试。相反，如果任何标志显式设置为 false，则仅禁用那些测试。因此 -printf=true 运行 printf 检查，而 -printf=false 运行除 printf 检查之外的所有检查。

## todo: go lint


## 参考资料
* https://go.dev/blog/gofmt
* https://go.dev/blog/godoc
* https://pkg.go.dev/golang.org/x/tools/cmd/godoc
* https://pkg.go.dev/cmd/vet
* https://medium.com/a-journey-with-go/go-vet-command-is-more-powerful-than-you-think-563e9fdec2f5
* https://eli.thegreenplace.net/2021/a-comprehensive-guide-to-go-generate/
