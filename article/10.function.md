# 函数

在之前，我们了解了简单的内置类型如何进行算术运算，这些运算是一种简单的过程。我们也看到了如何通过简单类型的组合进行更复杂的运算。
还看到了将变量名与变量的值绑定在一起，如何提高了程序的抽象水平。在本章中，我们还将看到一种定义过程的强大抽象技术—————函数。
通过函数，可以给一连串的复合操作定义一个名字，作为一个操作单元。我们在之前就已经频繁使用到了函数，例如用于打印的fmt.println函数。

## 函数声明
例如现在要定义一个程序，用于计算一个整数的平方。我们可以这样声明一个函数：
```
func square(x int) int{
    return x * x
}
```
函数的一般形式如下所示：
```
func name(parameter-list) (result-list) {
    body
}
```
函数声明有四个部分：关键字func、函数名、输入参数和返回值类型。函数体位于花括号中，函数体内部定义一系列的操作。
输入参数位于括号中，用逗号分隔。参数名称在前，类型在后。这些参数作为局部变量，其值由参数调用者提供。Go 是一种强类型语言，因此必须指定参数的类型。返回值列表描述了函数返回值的变量名以及类型，返回类型写在输入参数的右括号和函数体的左花括号之间，可能会有多个返回值。
如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。如果一个函数声明不包括返回值列表，那么函数体执行完毕后，不会返回任何值。
就像其他语言一样，Go 有一个 `return` 关键字用于返回值。如果函数有返回值，则函数体内部必须有`return`关键字。
如果函数无返回值，函数体中不需要 `return` 关键字。
main函数是Go语言中特殊的函数，他是用户函数的入口函数，没有参数和返回值。我们在hello world程序中已经看到了它的定义。
如果一组形参或返回值有相同的类型，我们不必为每个形参都写出参数类型。下面2个声明是等价的：
```
func f(i, j, k int, s, t string)
func f(i int, j int, k int,  s string, t string)
```
如果看到形参列表中包含`_`符号，代表其是一个预留的参数，此参数是未被使用的。
```
func first(x int, _ int) int
```

### 多返回值
函数可能会有多个返回值，这在c/c++语言中是不可能的。
我们经常在实践中看到多个返回值的例子是在第二个返回值中返回了函数的错误信息。如下例的除法运算中，除数不能为0，否则第二个返回值返回错误。关于error类型将在接口章节中详细介绍。
```
func div (a,b int) (int,error){
    if b == 0 {
     return 0, errors.New("b cat't be 0")
    }
    return a/b,nil
}
```

### 可变参数
可变参数也叫不变函数参数，指的是对应参数的个数可以是0个或多个。这在某些不清楚参数具体个数的情况下非常有用，典型的例子是之前经常使用的fmt.PrintLn函数，其声明如下，空接口interface{}是一个类型，将在接口章节详细介绍。
```
func Println(a ...interface{}) (n int, err error)
```
再举一个例子，我们希望写一个加法功能，但是参数可能是变化的，利用用户的所有订单支付金额的和，没办法提前定义，或者参数太长了，这个时候就可以使用不定参数。如下所示，不定参数仍然可以通过for range语句循环遍历每一个值，第一个参数为序号，第二个参数为对应的值。
```
func addsum(nums ... int) int {
	var sum int
	for _,value := range nums{
		sum +=value
	}
	return sum
}
```

## 函数的意义
在上例中，我们定义了一个程序，它被命名为square。
该程序表示将整数与自身相乘取平方的操作。被相乘的整数被赋予一个本地名称x。
这种方式和自然语言的处理是多么相似，当我们需要计算某一个数的平方时，如下调用函数名字即可。甚至不必关系函数内部实现的细节，成为了一个功能上的黑盒。这种对于功能的抽象，有利于关注点的分离，有利于书写更大规模的程序。

同时，函数体中的代码可能会很长。我们可以在任何地方使用相同的逻辑。如果不使用函数，代码将会无意义的多次重复出现。
```
a:= 3
b:= square(a)
```

## 递归
在之前我们了解到了简单类型的算术运算、以及运算的组合。本章之前的章节还介绍了如何将这些运算封装为函数，作为一个过程进行抽象。
但这还不足以知道如何编程。这就好像我们一开始掌握了象棋中的运行规则但是不了解典型的开局、战术或策略仍然下不好棋一样。
编程也一样，需要掌握该领域的一些通用模式和规则。对于新手，还缺少一些经验来掌握哪一些过程值得被定义为函数，程序执行之后会发生什么后果
能够在头脑中想象出不同程序运行的过程和结果是成熟的开发者必备的技能。只有在我们掌握了这样的技能之后，才能学会如何可靠地构建起能够表现出所需行为和结果的程序。
在本小节中，将介绍一种简单且经典的模式———递归，通过递归探究程序的运行过程。
递归指的是在函数中调用自身的情况，这在一些复杂的场景下用于将复杂的问题转换为简单的问题非常有用，其本身体现了一种解决问题的思想。假设要解决的一个问题是求数字n的阶乘，其数学表达为：
n! = n * (n-1) * (n-2) * (n-3) ... 3*2*1
假设有一个函数 f(n) = n! 那么f(n) = n * (n-1)! = n * f(n-1), 这在数学进行归纳推理证明时非常常见。这种思想转换为编程的形式可以书写如下:
```
func f(n int) int {
	if n == 1 {
		return 1
	}
	return n * f(n-1)
}
```
简单的程序可能具有强悍的美，笔者最初在接触编程时，就被递归的3行代码解决著名的汉诺塔问题深深吸引了！对于一个初学者，可能很难想象上例这样的程序是如何运行的，这时可以选择一个小点的数n逐步去推演运行的过程。
如下所示：f(6) 其执行过程为：
f(6) ->
6 * f(5) ->
6 * (5 * f(4)) ->
6 * (5 * (4 * f(3))) ->
6 * (5 * (4 * (3*f(2)))) ->
6 * (5 * (4 * (3* (2*f(1))))) ->
6 * (5 * (4 * (3* (2*1)))) ->
6 * (5 * (4 * (3* 2))) ->
6 * (5 * (4 * 6)) ->
6 * (5 * 24) ->
6*120 ->
720

对于阶乘，我们还可以用另一种思维来思考，即首先计算1*2，，然后将结果乘以 3，然后乘以 4，依此类推，直到最后到达 n ，这是递归的另一种表现形式。
在这里我们需要维护了一个总数total， 以及计数器count。

其代码如下所示：
```
func f2(n int) int {
	return fiter(1, 1, n)
}

func fiter(total, count, max int) int {
	if count > max {
		return total
	}
	return fiter(total*count, count+1, max)
}
```

而其执行的顺序如下所示：
f2(6)          ->
fiter(1,1,6)   ->
fiter(1,2,6)   ->
fiter(2,3,6)   ->
fiter(6,4,6)   ->
fiter(24,5,6)  ->
fiter(120,6,6) ->
fiter(720,7,6) ->
720

上面的两个程序在计算逻辑上都是执行相同的乘法序列，在结果上也是一致的。但是在过程的演变上却完全不同。由于第一个程序的计算始终依赖于后一个程序的计算结果，因此程序延迟计算直到所有的最后一个函数得到了扩展。
因此其执行结构呈现出了先膨胀后收缩的特性，其类似于一棵树，并且这种扩展的长度与n成正比。但是第二个程序的结构不会随着n的增大而扩展，这种形式被称为尾递归。这是由于我们始终跟踪和维持了3个状态变量total, count, max，而显然第一个程序需要维护的变量更多。
有一些高级的编译器会对尾递归进行优化，因为尾递归形式总是可以转化为不使用递归的迭代形式。
递归在一些复杂问题上有强大的表现力，不管是汉诺塔、八皇后、操作树结构，快速排序这些复杂问题上，都有惊人的表现力。递归在处理将复杂问题转换为多个简单的子问题上表现优良，但是其本身也有一些缺陷。
第一是递归相对复杂，不太容易调试。第二方面是现代操作系统在处理函数计算时采用了栈增长的方式，而递归恰恰需要调用自身函数，在非常多的函数调用时，甚至会带来内存的压力甚至栈溢出。

如果在一个函数中多次调用了自身，这种情况会变得更加复杂。在下面的例子中，通过斐波拉契数列来说明这种复杂递归的形式，更重要的是说明复杂程序的执行过程。

斐波拉契如下，其第一个数字为0，第二个数字为1，其后的每一个数字都是前两个数字的和。
0 1 1 2 3 5 8 13 21 34...
其数学公式如下:


用程序可以表示为：
```
func fib(n int) int {
	if n == 0 {
		return 0
	}
	if n == 1 {
		return 1
	}
	return fib(n-1) + fib(n-2)
}
```
程序f(5)的处理过程可以表示如下：

其形式类似于一棵树，又被叫做树递归，也是一种很常见的模式。 在上例中，有一些过程被重复执行了，例如上例中的fib(2) 执行了3次，这其实是没有必要的，可以通过类似上例尾递归维护状态的形式解决重复计算的问题:
```
func fib2(n int) int {
	return fibter(1,0,n)
}
func fibter(a, b, count int) int {
	if count == 0 {
		return b
	}
	return fibter(a+b, a,count-1 )
}
```
但这并不意味着树递归形式是没有用的，在解决复杂层次结构的问题，例如数据结构中的树操作时，是一种强大的工具。同时在本节中，其也提供了一种思想，帮组我们理解复杂程序的运行过程。

## 函数作为参数
在Go 语言中，函数是一等公民（first-class），这意味着可以将它看作变量，并且它可以作为参数传递、返回及赋值。那么这样的能力会给程序带来什么丰富的表现力？
在之前定义了求平方的square函数。通过为通用模式分配名称来构建抽象，这种方式使我们程序有能力表达平方的概念，并在此基础上构建复杂程序。但是在之前我们处理的参数都是简单的数值，这限制了程序的抽象能力。
通常相同的操作模式可以用于表达不同的过程。为了将这些模式表达为概念，我们需要构造可以接受函数作为参数或返回值的函数。本节将展示这种高阶函数形式如何形成强大的抽象机制，极大地增强语言的表达能力。
考虑下面的三个程序，第一个程序add是计算整数从a到b的数字和,第二个程序addSquare是计算整数从a到b的平方和,第三个程序addCubes是计算整数从a到b的立方和,
```
func add(a, b int) {
	sum := 0
	for i := a; i <= b; i++ {
		sum += sum + i
	}
}

func addSquare(a, b int) {
	sum := 0
	for i := a; i <= b; i++ {
		sum += sum + i*i
	}
}

func addCubes(a, b int) {
	sum := 0
	for i := a; i <= b; i++ {
		sum += sum + i*i*i
	}
}
```

这三个程序显然都有相同的计算模式，它们大部分的逻辑是相同的，只是函数的名称、以及对整数的处理是不同的。要将这些函数统一为单个函数抽象，我们可以将函数改写如下：
```
func addCommon(handle func(int) int, a, b int) {
	sum := 0
	for i := a; i <= b; i++ {
		sum += sum + handle(i)
	}
}
```
于是，我们将处理特定求和的程序，转化为了处理通用求和的函数，和数学中抽象类似。从此，当我们需要求和时，转换为了调用addCommon程序，这进一步提高了函数的抽象能力。addCommon的第一个参数为函数，在下例中，`func(a int) int { return a }`是一个特殊的匿名函数，其不需要有名字，可以理解为用完即失效。
```
	// 简单数字求和
	addCommon(func(a int) int { return a }, 1, 10)
	//平方和
	addCommon(func(a int) int { return a * a }, 1, 10)
	// 立方和
	addCommon(func(a int) int { return a * a * a }, 1, 10)
```

函数作为参数的使用场景还非常多，例如书写中间件，回调等多种场景。
下面的代码实现对切片的遍历操作，遍历中访问每个元素的操作使用匿名函数来实现，用户传入不同的匿名函数体可以实现对元素不同的遍历操作，代码如下：
```
package main
import (
    "fmt"
)
// 遍历切片的每个元素, 通过给定函数进行元素访问
func visit(list []int, f func(int)) {
    for _, v := range list {
        f(v)
    }
}

func main() {
    // 使用匿名函数打印切片内容
    visit([]int{1, 2, 3, 4}, func(v int) {
        fmt.Println(v)
    })
}
```

## 函数作为返回值
函数作为返回值也能够进一步提高函数的表现力，比如看看下面的实际案例，下面是简单的创建了一个http服务器，
其中http.HandleFunc("/hello",hello)，第一个参数为访问的路由地址，第二个参数为处理函数，函数形式为：
```
func (w http.ResponseWriter,  r *http.Request)
```
当服务开启之后：就可以在浏览器中输入http://127.0.0.1:8080/hello进行访问，会调用hello函数，访问的结果会在页面上输出hello jonson字符。

```
func hello( w http.ResponseWriter,  r *http.Request) {
	fmt.Fprintf(w,"hello jonson")
}
func main(){
	server:= http.Server{ Addr:"127.0.0.1:8080"}
	http.HandleFunc("/hello",hello)
	server.ListenAndServe()
}
```

假设现在我们需要在每次用户调用url时打印一些日志等信息，这是很常见的需求，那么一种思路是在hello函数中加入一行打印日志，如下所示：
```
func hello( w http.ResponseWriter,  r *http.Request) {
	log.Println(r.URL.Path)
	fmt.Fprintf(w,"hello jonson")
}
```
然而程序中可能会有很多的路由函数，如果每一个都需要进行修改，耗时耗力，那么有没有一种办法解决这样的问题呢？这就是常见的middleware中间件发挥用途的地方。
如下书写了logging函数，其参数为函数`http.HandlerFunc`，其实就是`func (w http.ResponseWriter,  r *http.Request)`类型，返回值也一样。
在构造的返回的函数体中，在调用传递进来的函数之间，执行了一行打印的逻辑。
```
func logging(f http.HandlerFunc) http.HandlerFunc{
	return func(w http.ResponseWriter, r *http.Request) {
		log.Println(r.URL.Path)
		f(w,r)
	}
}
```

现在，就可以把之前的程序稍微修改如下，即实现了打印日志的目的:
```
http.HandleFunc("/hello",logging(hello))
```

以后即便有其他路由函数均可简单修改即可完成统一的日志打印：
```
	http.HandleFunc("/hello",logging(hello2))
	http.HandleFunc("/world",logging(hello3))
	http.HandleFunc("/world",logging(hello4))
```

## 函数作为值
函数作为一类公民，也可以作为值，这意味着同一个函数函数变量可以被替换，从而执行不同的功能。这种模式在C语言中也非常常见，在C语言中通过修改函数指针的方式，让函数指针指向不同的函数。例如根据传递过来的网络包协议的不同，选择调用不同的处理函数，在操作系统内核中使用广泛。
在这里举一个例子，假设我们希望实现一个计算器的功能，例如捕获用户输入进来的"2", "+", "3"，都是字符串，那么如何把他们转换为实际操作呢？
首先是需要识别用户想要的操作是"+"，还是"-"，从而执行对应的函数。我们当然可以使用if语句来实现：

```
func add(i int, j int) int { return i + j }
func sub(i int, j int) int { return i - j }
func mul(i int, j int) int { return i * j }
func div(i int, j int) int { return i / j }

func Operator(i int,j int,op string){
    if op == "+"{
           add(i,j)
    }else if op == "-"{
           sub*(i,j)
    }
    ...
}
```
但是我们也可以换一种思路，通过op获取到函数变量，接着直接调用函数。opMap是一个哈希表，将在下一章中介绍用于从指定key中获取对应的value。
这种模式更便于维护修改，当我们需要加上一个新的操作，"%"，只需要在哈希表中添加一行，这比修改if结构要容易很多。

```
var opMap = map[string]func(int, int) int{
    "+": add,
    "-": sub,
    "*": mul,
    "/": div,
}

f := opMap[op]
f()
```
## 匿名函数
在上一节介绍函数作为参数时，已经介绍了匿名函数在实际中的用途，他们不用带函数名，不用分配给变量，可以立即被调用。
其实匿名函数在实际中很常见，比如当我们涉及到后面将涉及到的延迟调用以及协程时，很多都是采用匿名函数的形式。

## 闭包
在介绍函数的作用域时，我们就知道了函数内部的变量，其作用域只在函数体内。 一个函数不能够去访问另一个函数内的变量。
但是闭包这种形式有所不同。闭包是一个计算机科学术语，表示在函数内部声明的函数能够访问和修改在外层函数中声明的变量。
如下例中，greet函数内部定义了一个increment函数，increment函数是一个闭包，其内部引用了外层的x，并执行了加1操作。
当我们多次调用increment函数时，实际上也修改了原始的x值。
```
func greet(){
	x:=0
	increment:= func() int{
		x++
		return x
	}
	fmt.Println(increment())
	fmt.Println(increment())
}
```

上例输出结果为：
```
1
2
```

在介绍函数作为返回值时，其实就已经体会了闭包的妙用，下面是通过闭包设计的一个http 中间件，通过闭包可以轻易地在原有函数的基础上包裹中间功能，打印函数运行的时间，而不破坏原有函数。
```
func main() {
	http.HandleFunc("/hello", timed(hello))
	http.ListenAndServe(":3000", nil)
}
func timed(f func(http.ResponseWriter, *http.Request))
func(http.ResponseWriter, *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()
		f(w, r)
		end := time.Now()
		fmt.Println("The request took", end.Sub(start))
	}
}
```
当闭包作为另一个函数的参数或者返回值，其变得更加有趣。闭包可以在不修改原有函数声明结构的基础上对函数进行扩展，同时，在不声明全局变量的情况下，延长了原有变量的作用域。

## 值传递
值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。
默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。

```
/* 定义相互交换值的函数 */
func swap(x, y int) int {
   var temp int

   temp = x /* 保存 x 的值 */
   x = y    /* 将 y 值赋给 x */
   y = temp /* 将 temp 值赋给 y*/

   return temp;
}
```
接下来，让我们使用值传递来调用 swap() 函数：
```
package main

import "fmt"

func main() {
   /* 定义局部变量 */
   var a int = 100
   var b int = 200

   fmt.Printf("交换前 a 的值为 : %d\n", a )
   fmt.Printf("交换前 b 的值为 : %d\n", b )

   /* 通过调用函数来交换值 */
   swap(a, b)

   fmt.Printf("交换后 a 的值 : %d\n", a )
   fmt.Printf("交换后 b 的值 : %d\n", b )
}

/* 定义相互交换值的函数 */
func swap(x, y int) int {
   var temp int

   temp = x /* 保存 x 的值 */
   x = y    /* 将 y 值赋给 x */
   y = temp /* 将 temp 值赋给 y*/

   return temp;
}
```

以下代码执行结果为：
```
交换前 a 的值为 : 100
交换前 b 的值为 : 200
交换后 a 的值 : 100
交换后 b 的值 : 200
```


参考资料：
* 《Structure and Interpretation of Computer Programs》 1.2  Procedures and the Processes They Generate