# 复合类型
在之前我们都是对于简单的数据进行操作。对于我们希望使用计算解决的许多问题，简单的数据是不够的。程序通常设计用于对复杂现象进行建模，并且改建模的对象通常具有多种不同的特性。
因此为我们构造了用简单类型以某种方式组合起来的复合类型。复合类型将我们对程序设计的抽象提升到一个更高的级别，增加设计的模块化，并增强我们语言的表达能力。
例如，考虑我们要处理分数。分数有分子和分母之分，如果我们只有基础的数据类型，这种处理将变得繁琐。而如果有了复合类型。我们可以将分子和分母看做一个整体。
形成复合数据的关键是编程语言应该提供某种“胶水”，以便可以组合数据对象以形成更复杂的数据对象。这种数据抽象将使程序更易于设计、维护和修改。
在本章中我们将看到Go语言中内置的复合类型数组、切片、哈希表，以及用户自定义的结构体如何提供了上述描述的优势。

## 数组
几乎所有主流语言都支持数组，它是相同类型的元素组合而成的列表，是一片连续的内存区域。在现实很多场景中，都需要将一组对象作为一个整体捆绑在一起，便于操作和查找，他们常常还是有序的。例如一个班级中的学生，一本书籍的目录。
数组的声明有多种形式，如下简单的声明指定数组的元素类型和长度。
```
var arr [3]int
```
可以在声明的同时为数组赋值，如
```
var arr2= [4]int{1,2,3,4}
```
如果想定义一个稀疏数组（大多数元素设置为零值的数组），可以仅对数组中有值的元素进行赋值。如下所示：
```
var x = [12]int{1, 5: 4, 6, 10: 100, 15}
```
上面定义的数组x是拥有12个int元素，其值为： [1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15].
数组还有一种语法糖，可以不用指定类型
```
arr3 :=[...]int{2,3,4}
```
这种声明方式在编译时自动推断长度。Go 中的数组很少使用，与其他语言中的数组有显著不同的特性。这是因为其有诸多限制：例如不能进行扩容，Go 将数组的大小视为数组类型的一部分。
这使得声明为[3]的数组与声明为[4]int的数组不同。数组的大小无法改变，因为数组类型在编译时即解析，而不是在运行时解析。同时无法将不同大小的数组相互转换，所以无法编写适用于任何大小数组的函数，也无法将不同大小的数组分配给同一个变量。
要读取数组中的元素，可以指定数组的索引。索引以从零开始的位置进行，这意味着第一个元素的索引是 array[0]，最后一个元素的索引是 array[len(array)-1] .
注意索引不能够为负数或者超过数组的大小。否则会在编译时或者运行时出现严重错误。
```
x[0] = 10
fmt.Println(x[2])
```
您不能读取或写入超出数组末尾的索引或使用负索引，否则会出现编译错误。带有变量索引的越界读取或写入编译但在运行时会因恐慌而失败（我们将在“恐慌和恢复”中详细讨论恐慌）。
最后，go提供了内置的函数len用于获取数组的长度。
```
fmt.Println(len(x))
```

更复杂的，我们还可以构造出二维数组，例如var x [2][3]int,形式上可以将其想象为数组中每一个元素又都是数组。这种二维数组在可以模拟类似棋盘游戏等需要二维的场景。例如可以将 a[1][2] 代表棋盘上第一行第2列的元素。
如下例所示，使用二维数组模拟打印出一个五子棋棋盘，并且可以存储当前红黑双方落子的情况。X代表红方，O代表黑方。我们会看到，再复杂的图形化界面背后都离不开这些简单的数据结构和逻辑。随着学习的深入，我们可以实现人人对战，人机对战的五子棋程序了。你可能会感到不可思议，其实现在你就有能力书写这样的程序了！
```
func main() {
	var arr = [5][5]int{}
	arr[2][2] = 1
	arr[2][3] = 2
	for i := 0; i < len(arr); i++ {
		for j := 0; j < len(arr[i]); j++ {
			switch arr[i][j] {
			case 0:
				fmt.Printf("%3s", ".")
			case 1:
				fmt.Printf("%3s", "X")
			case 2:
				fmt.Printf("%3s", "O")
			}
		}
		fmt.Println()
	}
}

```


## slice切片
由于数组的诸多限制，在Go程序中更多是使用切片，切片提供了扩容等更强的能力，并且可以写一个函数用于处理不同长度的切片。
Go 语言中的切片（slice）在某种程度上和其他语言（例如C语言）中的数组在使用中有许多相似的地方。
但是Go 语言中的切片也有许多独特之处，例如，切片是长度可变的序列。序列中的每个元素都有相同的类型。一个切片一般写作[]T，其中T 代表slice 中元素的类型。
和数组不同的是，切片不用指定固定长度。切片有多种声明方式，如下所示，在初始化情况下可以不用声明数组的长度。对于切片numbers，编译器会自动推断出切片初始化的长度，并使其容量与长度相同。
```
var slice1 []int
numbers:= []int{1,2,3,4,5,6,7,8}
```
和数组一样，切片也可以定义稀疏矩阵。
```
var x = []int{1, 5: 4, 6, 10: 100, 15}
```
这将创建一个具有12 个整数的切片：[1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15]。

除了上面提到的使用初始化的方式，实际中更常见的的方式是使用内置函数make，如下所示：
```
var slice2 []int = make([]int,5)
var slice3 []int = make([]int,5,7)
```
切片有长度和容量的区别，可以在初始化时指定。由于切片具有可扩展性，所以当它的容量比长度大时，意味着为切片元素的增长预留了内存空间。上例中slice2 指定了长度为5 的int切片，如果不指定容量，则默认其容量与长度相同。
slice3第二个参数7声明切片的容量。内置的len 和cap 函数可以分别获取切片的长度和容量。
```
slice := make([]int,0)
fmt.Printf("len=%d,cap=%d,slice=%v\n",len(slice),cap(slice),slice)
```

### append
切片初始化时的长度可以声明为0。
```
var slice2 []int = make([]int,0)
```
这在不明确切片的大小和运行中切片是否有值时很有用，这不用分配额外的内存。相反，如果我们初始化时就知道切片大概的大小，在初始化时一般会提前声明切片的大小。这主要是为了避免切片扩容过程中多余的操作。
切片拥有增加元素，即扩容的能力。可以使用内置的append函数添加值。
```
var x []int
x = append(x, 10)
```
append 函数至少有两个参数，一个任意类型的切片和一个该类型的值。append函数返回相同类型的切片，同时返回的切片需要分配回传入的切片。
append 也可以添加多个值：
```
x = append(x, 5, 6, 7)
```

使用"..."操作符,还可以将一个切片添加到另一个切片中，
```
y := []int{20, 30, 40}
x = append(x, y...)
```
append这种写法看起来有点奇怪而且重复，为什么需要将append函数返回的值再赋值给传入的值，而不是直接append(x,value)呢？这涉及到go语言的设计哲学，即参数传递是值拷贝。传入到函数中的参数x会建立一个新的副本。因此需要将添加元素后返回的新副本赋值给原始的变量。

### 切片的容量
切片是一个序列，切片中的每个元素都被分配到连续的内存位置，这样可以快速读取或写入这些值。
由于切片可以动态扩容，切片拥有容量这一新概念，即保留的连续元素的数量，容量可以大于长度。每次附加到切片时，都会将一个或多个值添加到切片的末尾。每增加1个值，长度就会增加1。
当长度达到容量时，就没有更多的空间来放置值了。如果当前切片的长度等于容量时添加其他值会发生什么呢？这时 append 函数会自动分配具有更大容量的新切片，将原始切片中的值复制到新切片中，将新值添加到末尾，并返回新切片。
内置的函数len和cap可以获取切片的大小和容量。扩容时并不是每一次只增加一个元素大小，这样效率太低了，相反，扩容时有一些策略使得一次扩容多个元素大小，但是讨论这些策略超出了本书的范围，可参阅《Go语言底层原理剖析》。
但我们可以通过下面的案例观察切片的长度和容量随着append的变化。
```
var x []int
fmt.Println(x, len(x), cap(x))
x = append(x, 10)
fmt.Println(x, len(x), cap(x))
x = append(x, 20)
fmt.Println(x, len(x), cap(x))
x = append(x, 30)
fmt.Println(x, len(x), cap(x))
x = append(x, 40)
fmt.Println(x, len(x), cap(x))
x = append(x, 50)
fmt.Println(x, len(x), cap(x))
```
### 切片的截取
和数组一样，切片中的数据仍然是内存中的一片连续区域。要获取切片某一区域的连续数据，可以通过下标的方式对切片进行截断。
其形式为在方括号内，由一个起始偏移量和一个结束偏移量组成，并且用冒号分隔。如果省略了起始偏移量，则起始偏移量为0。同样，如果省略了结束偏移量，则代表到达切片的结尾。
被截取后的切片，其长度和容量都发生了变化。
```
numbers:= []int{1,2,3,4,5,6,7,8}
// 从下标2 一直到下标4，但是不包括下标4
numbers1 :=numbers[2:4]
// 从下标0 一直到下标3，但是不包括下标3
numbers2 :=numbers[:3]
// 从下标3 一直到结尾
numbers3 :=numbers[3:]
```
如下，变量number1 包含了切片中第2、3 号元素。切片的长度变为了2，容量变为了6，即从第2号元素开始到切片的末尾。
有时候我们希望number1的容量不是6，而是和长度相同，可以使用如下更复杂的截取形式。如下number4方括号中最后的元素4代表窃取后的新切片的容量是序列4。
```
func main() {
	numbers := []int{1, 2, 3, 4, 5, 6, 7, 8}
	// 从下标2 一直到下标4，但是不包括下标4
	numbers1 := numbers[2:4]
	fmt.Println("len:", len(numbers1), "cap:", cap(numbers1))
	numbers4 := numbers[2:4:4]
	fmt.Println("len:", len(numbers4), "cap:", cap(numbers4))
}
```
输出结果为：
```
len: 2 cap: 6
len: 2 cap: 2
```
为什么我们在有些时候需要控制截取后切片的容量呢？这是由于原始切片中的任何未使用容量也与任何子切片共享。这可能导致严重的问题。
切片被截取时有一个重要的特点，被截取后的切片仍然指向原始切片的底层数据。如下所示，y截取了切片x的前两个元素，其容量为4。
```
x := []int{1, 2, 3, 4}
y := x[:2]
fmt.Println(cap(x), cap(y))
y = append(y, 30)
fmt.Println("x:", x)
fmt.Println("y:", y)
```

由于x与y共享同样的底层数组，因此当切片y `append` 一个元素时，其实际上也修改了切片x的值。上例输出为：
```
4 4
x: [1 2 30 4]
y: [1 2 30]
```

但是如果我们限制了变量y的容量和长度相同，那么y在append时候会进行扩容，扩容后新的切片的底层数据将不会再和切片x共享。如下所示，其最终的结果和上例不同，这种不明确的特性是使用切片过程中一个常见的陷阱。
```
	x := []int{1, 2, 3, 4}
	y := x[:2:2]
	fmt.Println(cap(x), cap(y))
	y = append(y, 30)
	fmt.Println("x:", x)
	fmt.Println("y:", y)
```
输出为：
```
4 2
x: [1 2 3 4]
y: [1 2 30]
```

由于切片截取时候的陷阱，我们在实际使用时需要谨慎使用，特别是遇到切片截取 和append函数复用时，在必要时，限制新切片的容量，从而避免新的切片和旧的切片的区别。

### slice底层结构
简单介绍一下切片的底层结构是怎么样的，这是由于对于slice底层结构的认识，可以让我们更加理解切片在截取时候为什么会产生不同的行为。
切片运行时结构如下所示：
```
foo := make([]int,5)
foo[3] = 42
foo[4] = 100
bar := foo[1:4]
bar[1] = 99
```
在这段代码中，bar 截取了foo 切片中间的元素，并修改了bar 中的第2 号元素，程序执行完成后，其底层结构如图所示，
我们可以看到，切片的截取或者复制其实都是创建了一个新的副本结构，其长度和容量发生了变化，但是指向的底层结构是相同的。而当副本在apend扩容之后，由于其指向了新的底层数据，因此变得互不影响。

## 参考资料
*《Structure and Interpretation of Computer Programs》 Chapter2 Building Abstractions with Data